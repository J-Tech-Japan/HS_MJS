<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Adobe RoboHelp 2017" />
<title></title>
<link rel="StyleSheet" href="MJSHELP2002.css" type="text/css" />
<link rel="StyleSheet" href="font.css" type="text/css" />
<link rel="StyleSheet" href="resp.css" type="text/css" />
<style type="text/css">
<!--
A:visited { color:purple; }
A:link { color:#337AB7; }
-->
</style>
<script type="text/javascript" language="JavaScript">
//<![CDATA[
function reDo() {
  if (innerWidth != origWidth || innerHeight != origHeight)
     location.reload();
}
if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
   origWidth = innerWidth;
   origHeight = innerHeight;
   onresize = reDo;
}
onerror = null; 
//]]>
</script>
<style type="text/css">
<!--
div.WebHelpPopupMenu { position:absolute;
left:0px;
top:0px;
z-index:4;
visibility:hidden; }
p.WebHelpNavBar { text-align:right; }
-->
</style>
<script type="text/javascript" src="template/scripts/rh.min.js"></script>
<script type="text/javascript" src="template/scripts/common.min.js"></script>
<script type="text/javascript" src="template/scripts/topic.min.js"></script>
<script type="text/javascript" src="template/scripts/constants.js"></script>
<script type="text/javascript" src="template/scripts/utils.js"></script>
<script type="text/javascript" src="template/scripts/mhutils.js"></script>
<script type="text/javascript" src="template/scripts/mhlang.js"></script>
<script type="text/javascript" src="template/scripts/mhver.js"></script>
<script type="text/javascript" src="template/scripts/settings.js"></script>
<script type="text/javascript" src="template/scripts/XmlJsReader.js"></script>
<script type="text/javascript" src="template/scripts/loadparentdata.js"></script>
<script type="text/javascript" src="template/scripts/loadscreen.js"></script>
<script type="text/javascript" src="template/scripts/loadprojdata.js"></script>
<script type="text/javascript" src="template/scripts/mhtopic.js"></script>
<script type="text/javascript" src="template/scripts/jquery-3.1.0.min.js"></script>
<script type="text/javascript" src="template/scripts/resp.js"></script>
 <link rel="stylesheet" type="text/css" href="template/styles/widgets.min.css">
 <link rel="stylesheet" type="text/css" href="template/styles/topic.min.css">
<script type="text/javascript" >
gRootRelPath = ".";
gCommonRootRelPath = ".";
//gTopicId = "";
//refPage = {};
//mergePage = {};
	 url = [];

		// メイン処理
		$(function () {
			// refPageの初期化 - 値の長さで降順ソートしてオブジェクトを再構築
			// これにより、より長い文字列にマッチする参照が優先的に処理される
			refPage = Object.values(refPage).sort((a, b) => b[1].length - a[1].length).reduce(
				(result, value) => {
					const key = Object.keys(refPage).find(k => refPage[k] === value);
					result[key] = value;
					return result;
				},
				{}
			);

			const text = window.location.href;
			// 現在のURLからページIDを抽出（例：KAI01005.html → KAI01005）
			const pageMatch = text.match("[/][A-Z]{3}[0-9]{5}[.]html");

			if (pageMatch === null) {
				return;
			}

			// ファイル名からページIDを抽出（.htmlと先頭の/を除去）
			const id = pageMatch[0].replace("/", "").replace(".html", "");

			// mergePage内のIDチェックとリダイレクト
			// ファイルプロトコル以外の場合（サーバー上での実行時）のみ処理
			if (location.protocol !== "file:") {
				for (const key in mergePage) {
					// 現在のページIDがマージ対象の場合、最初のページにリダイレクト
					if (mergePage[key] === id) {
						const newid = findFirstPageInMerge(id);
						// URLフラグメント（#以降）を保持してリダイレクト
						const ref = window.location.href.split('.html#')[1];
						if (ref === '' || ref === undefined) {
							document.location.href = newid + ".html#" + id;
						} else {
							document.location.href = newid + ".html#" + ref;
						}
						return;
					}
				}
			}

			loadNextPage(id);

			if (url.length > 0) {
				handleDynamicPageLoad(text);
			} else {
				handleStaticPageLoad(text);
			}
		});

		// mergePage内で最初のページを再帰的に検索
		function findFirstPageInMerge(page) {
			let found = false;
			for (const key in mergePage) {
				if (mergePage[key] == page) {
					found = true;
					return findFirstPageInMerge(key);
					break;
				}
			}
			if (!found) {
				return page;
			}
		}

		// 次のページを再帰的に読み込み
		function loadNextPage(id) {
			if (mergePage[id] !== undefined) {
				url.push({
					api: $.ajax({
						url: mergePage[id] + ".html"
					}),
					page: mergePage[id]
				});
				loadNextPage(mergePage[id]);
			}
		}

		// 動的ページロード処理（複数ページを結合）
		function handleDynamicPageLoad(text) {
			// 全てのAjaxリクエストの完了を待つ
			Promise.all(url.map(x => x.api))
				.then(responses => responses.forEach(
					(response, index) => {
						// レスポンスからHTMLを取得し、DOMに追加
						const html = $(response).find("div").parent();
						const di = $('body');
						// ページの先頭にアンカータグを追加（ページ内リンク用）
						$(html).find("div:first").html("<a id='" + url[index].page + "'></a>");
						// NoPageBreakクラスをHeading2に変更（スタイル調整）
						$(html).find("p.NoPageBreak").attr("class", "Heading2");
						di.append(html);

						processRefElements();
						processMJSRefElements();

						// URLにフラグメントがある場合、そこにジャンプ
						if (text.indexOf("#") > 0) {
							window.location.href = text;
						}

						// bodyの内容をmainタグで囲む（セマンティックHTML）
						di.html("<div></div><main>" + di.html() + "</main>");
					}
				));
		}

		// 静的ページロード処理（単一ページ）
		function handleStaticPageLoad(text) {
			processRefElements();
			processMJSRefElements();

			if (text.indexOf("#") > 0) {
				window.location.href = text;
			}

			const di = $('body');
			di.html("<div></div><main>" + di.html() + "</main>");
		}

		// .ref要素の処理
		function processRefElements() {
			$(".ref").each(function () {
				const refname = $(this).attr("name");
				$("[name=" + refname + "]").each(function () {
					$(this).append("<a name='" + refname + "'>");
				});
			});
		}


		// .MJS_ref要素内のリンクと.ref要素を処理
		function processMJSRefElements() {
			$(".MJS_ref").each(function () {
				// リンク要素の処理
				$(this).find('a').each(function () {
					processLink(this);
				});

				// .ref要素の処理
				$(this).find('.ref').each(function () {
					const name = $(this).attr("name");
					// _refサフィックスを持たない要素はスキップ
					if (name?.indexOf("_ref") === -1) {
						return;
					}

					// _refサフィックスを除去してクリーンな名前を取得
					const cleanName = name.replace("_ref", "");
					if (refPage[cleanName]) {
						const replaceStr = refPage[cleanName][1];
						// 同じページ内に対象の.ref要素が存在するかチェック
						if ($(".ref[name=" + cleanName + "]").length > 0) {
							// 同一ページ内リンクとして処理
							$(this).html($(this).html().replace(replaceStr, "<a href='#" + cleanName + "'>" + replaceStr + "</a>"));
						} else {
							// 外部ページへのリンクとして処理
							const expectUrl = findFirstPageInMerge(refPage[cleanName][0]) + ".html#" + cleanName;
							$(this).attr("href", expectUrl);
						}
					}
				});
			});
		}

		// リンク要素を処理してURLを適切に変換
		function processLink(linkElement) {
			const name = $(linkElement).attr("name");

			if (name?.indexOf("_ref") > -1) {
				return; // _ref を含む場合は処理しない
			}

			let currentUri = $(linkElement).attr('href').replace(/^\.\//, '');

			// URL タイプの判定と処理
			if (currentUri.match(/^https?:/)) {
				// 外部リンク - 何もしない
				return;
			}

			if (currentUri.match(/^#[A-Z]{3}[0-9]{5}$/)) {
				// 内部リンク - 何もしない
				return;
			}

			if (currentUri.startsWith("template/resource")) {
				// テンプレート用URL - 何もしない
				return;
			}

			if (currentUri.includes("#t=")) {
				// 既に #t= 形式の場合は何もしない
				return;
			}

			if (!areDirectoriesEqual(currentUri) && checkFileName(currentUri)) {
				// 外部参照
				$(linkElement).attr('href', changeFileNameWithHash(currentUri));
				return;
			}

			const DOT_HTML_HASH = ".html#";

			// ファイル名とフラグメントが同じ場合（例：KAI01005.html#KAI01005）
			// refPage内のリンクとして処理
			if (currentUri.split(DOT_HTML_HASH)[0] === currentUri.split(DOT_HTML_HASH)[1]) {
				// refPage内のリンク処理
				const targetId = currentUri.split('.html#')[1];
				if (refPage[targetId]) {
					const expectUrl = refPage[targetId][0] + ".html#" + targetId;
					$(linkElement).attr('href', expectUrl);
				}
				return;
			}

			// その他の複雑なリンク処理
			// 拡張子を含むか、_Refを含む場合のみ処理
			if (!(currentUri?.indexOf(".") > 0 || currentUri?.indexOf("_Ref") > -1)) {
				return;
			}

			// URLからファイル名部分とフラグメント部分を抽出
			let subDestinationId = currentUri.split('.')[0];
			let destinationId = currentUri.split('#')[1] === undefined ? subDestinationId : currentUri.split('#')[1];

			// mergePage内での最初のページを検索
			// マージされたページチェーンを遡って最初のページを見つける
			for (let i = 0; i < Object.keys(mergePage).length; i++) {
				const startId = Object.keys(mergePage).find(key => mergePage[key] === subDestinationId);
				if (startId === undefined) break;
				subDestinationId = startId;
			}

			let href = "";
			// ファイル名とフラグメントが同じで、_Refを含む場合
			if (subDestinationId === destinationId && subDestinationId?.indexOf("_Ref") > -1) {
				// refPage内のリンク処理
				if (refPage[subDestinationId]) {
					href = refPage[subDestinationId][0] + ".html#" + destinationId;
				}
			} else {
				// 通常のページ内リンク処理
				href = subDestinationId + '.html#' + destinationId;
			}

			$(linkElement).attr('href', href);
			$(linkElement).attr('onclick', "anchorElement(href.split('#Ref')[0])");
		}

		// 相対パスが同一ディレクトリを指すかチェック
		function areDirectoriesEqual(relativePath) {
			if (!relativePath) return false;
			// スラッシュを含まない、または ./ で始まる場合は同一ディレクトリと判定
			if (!relativePath.match("/") || relativePath.match(/^\.\/.*/)) return true;

			// 現在のURLのディレクトリ部分を取得
			const currentUrl = window.location.href;
			const currentDir = currentUrl.substring(0, currentUrl.lastIndexOf('/'));
			// 相対パスを絶対URLに解決してディレクトリ部分を比較
			const baseUrl = window.location.origin;
			const resolvedUrl = new URL(relativePath, baseUrl).href;
			const resolvedDir = resolvedUrl.substring(0, resolvedUrl.lastIndexOf('/'));

			return currentDir === resolvedDir;
		}

		// パスから有効なファイル名かチェック
		function checkFileName(path) {
			// #t= 形式の場合は、#t= の後のファイル名をチェック（#以降は除去）
			const FILE_NAME_PATTERN = /^[A-Z]{3}[0-9]{5}[.]html$/;
			if (path.includes("#t=")) {
				const tParam = path.split("#t=")[1].split('#')[0];
				return tParam.match(FILE_NAME_PATTERN);
			}
			const fileName = path.split('/').pop().split(/[?#]/)[0];
			return fileName.match(FILE_NAME_PATTERN);
		}

		// ファイル名を#t=形式のハッシュパスに変換
		function changeFileNameWithHash(path) {
			// 既に #t= を含む場合はそのまま返す
			if (path.includes("#t=")) {
				return path;
			}
			// パスをディレクトリ部分とファイル部分に分割
			const parts = path.split('/');
			const filePart = parts.pop();
			const dirPart = parts.join('/');
			// #t=形式のハッシュパスとして再構築
			return dirPart ? `${dirPart}/${"index.html#t="}${filePart}` : `${"index.html#t="}${filePart}`;
		}

		// アンカー要素のナビゲーション処理
		function anchorElement(url) {
			if (window.location.href.indexOf(".html#") > -1) {
				window.location.href = url;
			}
		}
</script>
<meta name="topic-breadcrumbs" content="" />
</head>
<body style="text-justify-trim: punctuation;">